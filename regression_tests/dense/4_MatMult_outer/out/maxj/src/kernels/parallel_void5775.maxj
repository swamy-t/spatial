
			package engine;
			import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
			import com.maxeler.maxcompiler.v2.statemachine.DFEsmInput;
			import com.maxeler.maxcompiler.v2.statemachine.DFEsmOutput;
			import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateEnum;
			import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
			import com.maxeler.maxcompiler.v2.statemachine.kernel.KernelStateMachine;
			import com.maxeler.maxcompiler.v2.statemachine.types.DFEsmValueType;

			class void5775_ParSM extends KernelStateMachine {

				// States
				enum States {
					INIT,
					RUN,
					DONE
				}

				// State IO
				private final DFEsmOutput sm_done;
				private final DFEsmInput sm_en;

				private final DFEsmInput s0_done;
				private final DFEsmOutput s0_en;
				

				private final DFEsmInput s1_done;
				private final DFEsmOutput s1_en;
				

			// State storage
			private final DFEsmStateEnum<States> stateFF;
			private final DFEsmStateValue[] bitVector;

			private final int numParallel = 2;
			// Initialize state machine in constructor
			public void5775_ParSM(KernelLib owner) {
				super(owner);

				// Declare all types required to wire the state machine together
				DFEsmValueType counterType = dfeUInt(32);
				DFEsmValueType wireType = dfeBool();
				// Define state machine IO
				sm_done = io.output("sm_done", wireType);
				sm_en = io.input("sm_en", wireType);
				

				s0_done = io.input("s0_done", wireType);
				s0_en = io.output("s0_en", wireType);
				

				s1_done = io.input("s1_done", wireType);
				s1_en = io.output("s1_en", wireType);
				

			// Define state storage elements and initial state
			stateFF = state.enumerated(States.class, States.INIT);

			bitVector = new DFEsmStateValue[numParallel];
			for (int i=0; i<numParallel; i++) {
				bitVector[i] = state.value(wireType, 0);
			}
			}

			private void resetBitVector() {
				for (int i=0; i<numParallel; i++) {
					bitVector[i].next <== 0;
				}
			}

			@Override
			protected void nextState() {
				IF(sm_en) {
					

				IF (s0_done) {
					bitVector[0].next <== 1;
				}

				IF (s1_done) {
					bitVector[1].next <== 1;
				}

			SWITCH(stateFF) {
				CASE (States.INIT) {
					stateFF.next <== States.RUN;
				}
				

			CASE (States.RUN) {

					IF(bitVector[0] & bitVector[1]) {
						resetBitVector();
						stateFF.next <== States.DONE;
					}
			}

			CASE (States.DONE) {
				resetBitVector();
				stateFF.next <== States.INIT;
			}
			OTHERWISE {
				stateFF.next <== stateFF;
			}
			}
				}
			}
			

					@Override
					protected void outputFunction() {
						sm_done <== 0;

						s0_en <== 0;

						s1_en <== 0;

					IF (sm_en) {
						SWITCH(stateFF) {
							CASE(States.RUN) {
s0_en <== ~(bitVector[0] | s0_done);
s1_en <== ~(bitVector[1] | s1_done);

							}
							CASE(States.DONE) {
								sm_done <== 1;
							}
						}
					}
					}
			}
