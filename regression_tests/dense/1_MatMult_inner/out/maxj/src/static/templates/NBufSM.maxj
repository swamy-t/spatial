package engine;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmInput;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmOutput;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateEnum;
import com.maxeler.maxcompiler.v2.statemachine.DFEsmStateValue;
import com.maxeler.maxcompiler.v2.statemachine.kernel.KernelStateMachine;
import com.maxeler.maxcompiler.v2.statemachine.types.DFEsmValueType;
import java.util.ArrayList;
import java.util.List;

class NBufSM extends KernelStateMachine {

  // States
  enum States {
    RUNNING,
    RESET
  }

  private final int n;
  int max_bits; // Hack so that I don't need to codegen this SM

  // State IO
  private final DFEsmInput[] stageDone;
  private final DFEsmInput[] stageEn;
  private final DFEsmInput numBlanks;
  private final DFEsmInput broadcast;
  private final DFEsmOutput[] curBuf;

  // State storage
  private final DFEsmStateEnum<States> stateFF;
  private final DFEsmStateValue[] curBufFF;
  private final DFEsmStateValue stageDoneFF;
  private final DFEsmStateValue stageEnFF;
  private final DFEsmStateValue drainIterFF; // Tracking when to hold stable for last iter
  private final DFEsmValueType counterType;
  private final DFEsmValueType maxCounterType;


  // Initialize state machine in constructor
  public NBufSM(KernelLib owner, int nn, int bits, int hack_max_bits) {
    super(owner);

    n = nn; 
    max_bits = hack_max_bits;
    DFEsmValueType wireType = dfeBool();
    counterType = dfeUInt(bits);
    maxCounterType = dfeUInt(max_bits);

    // Define state machine IO
    stageDone = new DFEsmInput[hack_max_bits];
    curBuf = new DFEsmOutput[n];
    curBufFF = new DFEsmStateValue[n];
    stageEn = new DFEsmInput[hack_max_bits];
    broadcast = io.input("broadcast", wireType);
    numBlanks = io.input("numBlanks", counterType);
    for (int i = 0; i < n; i++) {
      stageDone[i] = io.input("stageDone" + i, wireType);
      curBuf[i] = io.output("curBuf" + i, counterType);
      curBufFF[i] = state.value(counterType, nn-i-1); // Reverse order;
      stageEn[i] = io.input("stageEn" + i, wireType);
    }
    for (int i = n; i < hack_max_bits; i++) {
      stageDone[i] = io.input("stageDone" + i, wireType);
      stageEn[i] = io.input("stageEn" + i, wireType);
    }

    // Define state storage elements and initial state
    stateFF = state.enumerated(States.class, States.RUNNING);
    stageDoneFF = state.value(maxCounterType, 0);
    stageEnFF = state.value(maxCounterType, 0);
    drainIterFF = state.value(counterType, 0);
  }

  private void resetBitVectors() {
    for (int i=0; i<n; i++) {
      stageEnFF.next <== 0;
      stageDoneFF.next <== 0;
    }
  }


  @Override
  protected void nextState() {
    SWITCH(stateFF) {
      CASE(States.RUNNING) {
        // TODO: Figure out how to reduce a bit vector with | lambda instead of this ugly 8-bit hack
        stageDoneFF.next <== (stageDone[0].cast(maxCounterType) << 0) |
                             (stageDone[1].cast(maxCounterType) << 1) |
                             (stageDone[2].cast(maxCounterType) << 2) |
                             (stageDone[3].cast(maxCounterType) << 3) |
                             (stageDone[4].cast(maxCounterType) << 4) |
                             (stageDone[5].cast(maxCounterType) << 5) |
                             (stageDone[6].cast(maxCounterType) << 6) |
                             (stageDone[7].cast(maxCounterType) << 7) |
                             stageDoneFF;
        stageEnFF.next <== (stageEn[0].cast(maxCounterType) << 0) |
                             (stageEn[1].cast(maxCounterType) << 1) |
                             (stageEn[2].cast(maxCounterType) << 2) |
                             (stageEn[3].cast(maxCounterType) << 3) |
                             (stageEn[4].cast(maxCounterType) << 4) |
                             (stageEn[5].cast(maxCounterType) << 5) |
                             (stageEn[6].cast(maxCounterType) << 6) |
                             (stageEn[7].cast(maxCounterType) << 7) |
                             stageEnFF;


        IF (stageDoneFF === stageEnFF & stageEnFF !== 0) {
          stateFF.next <== States.RESET;
        }
      }
      CASE(States.RESET) {
        // debug.simPrintf("\n\nSWAPPING BUFFERS\n\n");
        IF (stageEnFF === (1 << (n-1))) {
          IF (drainIterFF >= numBlanks) {
            drainIterFF.next <== 0;
            // If only last stage was enabled on this iter, then metapipe is done, do not inc
          } ELSE {
            drainIterFF.next <== drainIterFF + 1;
            for (int i = 0; i < n; i++) {
              IF (curBufFF[i] === n-1) {
                curBufFF[i].next <== 0;
              } ELSE {
                curBufFF[i].next <== curBufFF[i] + 1;
              }          
            }            
          }
        } ELSE {
          for (int i = 0; i < n; i++) {
            IF (curBufFF[i] === n-1) {
              curBufFF[i].next <== 0;
            } ELSE {
              curBufFF[i].next <== curBufFF[i] + 1;
            }          
          }
        }
        resetBitVectors();
        stateFF.next <== States.RUNNING;
      }
    }
  }

  @Override
  protected void outputFunction() {
    for (int i = 0; i < n; i++) {
      IF (broadcast) {
        curBuf[i] <== n;
      } ELSE {
        curBuf[i] <== curBufFF[i];
      }
    }
  }
}
