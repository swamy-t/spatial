# Spatial
Spatial is a Forge DSL for programming reconfigurable hardware from a parameterized, high level abstraction.

Prerequisites
=============

* Java JDK: http://www.oracle.com/technetwork/java/javase/downloads/index.html
* Scala SBT: http://www.scala-sbt.org
* **[Optional]** Sphinx: http://www.sphinx-doc.org/en/stable/ (autodocumentation)


Installation
============

Building Spatial requires the `spatial` branch of the hyperdsl (https://github.com/stanford-ppl/hyperdsl) project. Hyperdsl is itself composed of three submodules: Forge, Delite, and LMS, all of which also have a `spatial` branch.

To setup hyperdsl after cloning:

    cd hyperdsl
    git checkout spatial
    git submodule update --init

Set the following environment variables, requried for sbt and hyperdsl scripts:

    HYPER_HOME: hyperdsl repository home directory
    LMS_HOME: virtualization-lms-core repository home directory
    DELITE_HOME: Delite repository home directory
    FORGE_HOME: Forge repository home directory
    JAVA_HOME: JDK home directory

*init-env.sh* in hyperdsl sets the sensible defaults for all of these paths except `JAVA_HOME` for the current session. Add these variables to your login shell's startup script to avoid having to manually set these each session.

Now, clone Spatial to the directory of your choice and type:

    cd spatial && make

The setup script will prompt you for the `SPATIAL_HOME` environment variable. Press enter to use the current directory. To skip this message in the future, set this variable in your login shell's startup script.


**[Optional]** To track the most recent commits relevant to Spatial on each submodule of hyperdsl:

    cd $DELITE_HOME && git checkout spatial
    cd $FORGE_HOME && git checkout spatial
    cd $LMS_HOME && git checkout spatial


Introduction to Spatial
=======================
Now that you have cloned all of the code and set all of your environment variables, it is time to build and run your first Spatial app!  Because Spatial is a DSL for programming reconfigurable *hardware*, we will begin with the hardware equivalent of "Hello, World."   This app is known as ArgInOut and does exactly as the name implies; the hardware reads some numeric argument from an off-chip source and then echoes it back to an off-chip destination.

You can find the source code for this app here:

    $SPATIAL_HOME/apps/src/ArgInOutTest.scala

### Spatial App Anatomy
Spatial apps are divided into two parts: the portion of code that runs on the host CPU and the portion of code that gets generated as an accelerator.  The entirety of the app exists inside of `Main()`, and the subset of code inside of the `Accel{}` block is the hardware part of the app.  

In ArgInOut, we start with three declarations above the `Accel{}` block.  First, we declare x to be an `ArgIn` of type `SInt`.  Then, we declare y to be an `ArgOut` of type `SInt`.  Finally, we declare `N` to be one of the command-line input arguments at run-time by setting it equal to `args(0)`.  We must also explicitly cast this argument to a Spatial type by appending `.as[SInt]`.  In addition to ArgIns and ArgOuts, there is a type, `OffChipMem`, which represents a 1-D or 2-D array that the accelerator can read from and write to.

Now that we have both a val that represents an ArgIn and another val which reads some value from the command-line at runtime, we must connect the two with `setArg(<HW val>, <SW val>)`.  Similarly, we can connect an OffChipMem to an array with `setMem(<HW array>, <SW array>)`.  

Next, we specify the `Accel{}` block.  In this particular app, we simply want to add the number 4 to whatever input argument is read in.  To do this, we create a `Pipe` that consists of this primitive addition operation and writes the result to an ArgOut register with `:=`.  In later sections, you will learn what other operations and building blocks Spatial exposes to the developer.  

After the `Accel{}` block, we return to the host code section of an app that will interact with the result generated by the hardware.  Specifically, we start by assigning the ArgOut register to a SW variable with `getArg(<HW val>)`.  Similarly, we can assign an OffChipMem to a SW val with `getMem(<HW array>)`.

Finally, we add any debug and validation code to check if the accelerator is performing as expected.  In this example, we compute the result we expect the hardware to give, and then println both this number and the number we actually got.

### Compiling, Synthesizing, and Testing

Now that you have a complete Spatial app, you will want to compile and run it.  Currently, there are three available targets; Scala, Dot, and MaxJ.  This will show you how to build for MaxJ.

**NOTE: Any time you change an app, you must remake Spatial.**

Run the following commands to make your app:
    
    cd $SPATIAL_HOME
    make
    bin/spatial ArgInOut --maxj --cpp

This will create the directory `out/` in `$SPATIAL_HOME/published` that contains the generated code.  You must have the --cpp flag on even to generate MaxJ because this causes Delite to generate all of the necessary host code for the app. 

In order to test the MaxJ app, you must copy this `out/` directory to a machine with MaxCompiler 2014.1 or later.  If you want to test the code for functionality, you can force MaxCompiler to generate a CPP simulation of the app.  If you want to generate a bitstream to test the app on a Stratix V, you can get MaxCompiler to synthesize the entire design.  A build for simulation will take time on the order of minutes, while a build for synthesis will take time on the order of hours.  A simulation will ensure functionality but not runtime.

To build for simulation, run the following in the `out/` directory on a MaxCompiler machine:
    
    make clean sim
    bash run.sh <arguments>
    
To build for synthesis, run the following:
    
    make clean dfe
    bash run_fpga.sh <arguments>


The Spatial Programming Model
=============================
Coming Soon!


Design Space Exploration with Spatial
=====================================
Coming Soon!

